<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		To compute area-weighted normal of a given vertex, I first retrieved the half-edge structure of the given vertex so we can iterate through faces adjacent to the vertex. Then, for each face, we find the thre vertex positions of the given face, compute the normal vector by cross product two vectors, and compute the area of the triangle. Then, we normalize the normal vector by the area. Finally, I normalize the sum of all area-weighted normals.

			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part3_1.png" width="400px"/>
							<figcaption>Teapot shading without vertex normal</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part3_2.png" width="400px"/>
							<figcaption>Teapot shading with vertex normal </figcaption>
						</td>
					</tr>
				</table>
			</div>
		<h3>Part 4: Edge flip</h3>
		To implement edge flip function, first we check if the given edge is a boundary edge; if so, returns immediately. For each qualified non-bounary edge, we retriece it ten half edges, four vertices, two faces, and four edges. Then, we update face, halfedges, and vertices correspondingly. I found it very useful to draw out an example with labeled vertices, halfedges, edges, and faces to visualize the changes being done in flip edges.
			<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part4_1.png" width="400px"/>
							<figcaption>Before flip</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part4_2.png" width="400px"/>
							<figcaption>After flip </figcaption>
						</td>
					</tr>
				</table>
			</div>
		<h3>Part 5: Edge split</h3>
		Edge split is implemented by retrieving all the corresponding half edges, edges, and vertices. Then, we create new half edges(6), edges(3), vertices(1), and faces(2). We compute the position of the midpoint vertex by taking average of the vertex positions of the original edge. Then we update the half edge of verticies and faces and update half edges accordingly. At the end, we set the two newly created edges that are not on the direction of the original edge to new for part six. Like previous part, we found that by drawing out a specific example helps with understanding the concept and debugging our solution.
		<div style="display: flex; flex-direction: column; align-items: center;">
				<table style="width: 100%; text-align: center; border-collapse: collapse;">
					<tr>
						<td style="text-align: center;">
							<img src="images/part5_original.png" width="400px"/>
							<figcaption>Before split</figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part5_split.png" width="400px"/>
							<figcaption>After split </figcaption>
						</td>
						<td style="text-align: center;">
							<img src="images/part5_split_flip.png" width="400px"/>
							<figcaption>After split and flip </figcaption>
						</td>
					</tr>
				</table>
			</div>
		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		To implement loop subdivision, we need to first, compute new positions for all the vertices in the input mesh, using the Loop subdivision rule. The position of a new vertex U: 3/16 if n = 3, 3/(8n) otherwise. and store them in Vertex::newPosition. The updated version of an old vertex is: (1 - n * u) * original_position + u * original_neighbor_position_sum. We also mark each vertex that we loop through (the original vertex from the mesh) as old (isNew = false). Then we loop through edges and compute updated position of edges and store them in Edges::newPosition. If it's a boundary edge, the position is the average of two vertex positions, otherwise, it's computed by this formula: 3.0/8 * (a + b) + 1.0/8 * (c + d). Then, we iterate through the edges in the original mesh, setting their isNew to false and perform split edges. We set the midpoint created by split edge to new. Finally, we flip any edge that's connected by and old and new vertex. Finall, we copy over all the new vertex position to final Vertex::position

		During loop division, edges and corners are rounded. So in the example of the cube, we can see the cube has lost its six sides and looks more like a sphere. When we re-split the edge before perform loop subdivision,

		</div>
	</body>
</html>